# 日志系统

![none](https://s2.ax1x.com/2019/06/17/VHj5Of.png)

仿照Log4J的模式

**主要类**

- LogLevel：日志级别

- Logger：日志器
- LogAppender：日志输出地
  - StdoutLogAppender：输出到std::cout
  - FileLogAppender：输出到文件
- LogFormatter：日志格式
- LogEvent：日志事件
- LogEventWrap：日志事件包装器
- LoggerManager：日志器统一管理

## LogLevel类

定义了日志级别

```c++
enum Level {
    // 未设置
    UNKNOW = 0,
    // 调试信息
    DEBUG = 1,
    // 一般信息
    INFO = 2,
    // 警告
    WARN = 3,
    // 错误
    ERROR = 4,
    // 致命情况
    FATAL = 5
};
```

## LogEvent-日志事件类

日志事件类，用于记录日志，一行日志对应一个LogEvent类

主要包含以下内容：

```c++
// 文件名
const char* m_file = nullptr;
// 行号
int32_t m_line = 0;
// 程序启动到现在的毫秒数
uint32_t m_elapse = 0;
// 线程ID
uint32_t m_threadId = 0;
// 协程ID
uint32_t m_fiberId = 0;
// 时间戳
uint64_t m_time = 0;
// 线程名称
std::string m_threadName;
// 日志内容流
std::stringstream m_ss;
// 日志器
std::shared_ptr<Logger> m_logger;
// 日志等级
LogLevel::Level m_level;
```

### LogEventWrap-日志事件包装类

RAII？

在析构时处理（输出）包装的日志事件

## LogFormatter-日志格式化类

定义了以下日志内容项

```c++
%m 消息
%p 日志级别
%r 累计毫秒数
%c 日志名称
%t 线程id
%n 换行
%d 时间
%f 文件名
%l 行号
%T 制表符
%F 协程id
%N 线程名称
```

默认格式 `"%d{%Y-%m-%d %H:%M:%S}%T%t%T%N%T%F%T[%p]%T[%c]%T%f:%l%T%m%n"`

`%d{%Y-%m-%d %H:%M:%S}`：`%d`表示是时间，大括号的内容具体定义事件的日志格式

---

内部定义一个FormatItem纯虚类，其内部有一个纯虚函数`format`来对该日志内容项进行输出，对于上面写到的每个日志内容项，继承该纯虚类实现一个子类来解析各日志格式

如`%m`日志内容

```c++
class MessageFormatItem : public LogFormatter::FormatItem {
public:
    MessageFormatItem(const std::string& str = "") {}
    void format(std::ostream& os, Logger::ptr logger, LogLevel::Level level,
                LogEvent::ptr event) override {
        os << event->getContent();
    }
};
```

---

LogFormatter类的构造函数接受一个日志格式模板参数，来定义日志格式，默认格式 `"%d{%Y-%m-%d %H:%M:%S}%T%t%T%N%T%F%T[%p]%T[%c]%T%f:%l%T%m%n"`

内部定义了三个成员变量

```c++
// 日志格式模板
std::string m_pattern;
// 日志格式解析后格式
std::vector<FormatItem::ptr> m_items;
// 是否有错误
bool m_error = false;
```

- m_pattern是传入的日志格式模板
- m_items存储FormatItem纯虚类的子类，表明该日志格式需要用到哪些日志内容项类来进行输出
- m_error表示该日志格式模板是否正确

---

LogFormatter还有一个init函数，在构造函数内部进行调用，对日志格式模板进行解析

日志格式模板主要可以拆分成三类

```c++
%xxx %xxx{xxx} %%

%xxx 类型
%xxx{xxx} 类型{带格式}
%% 转义，我就要%字符
```

状态机：(可能不是很正确)

![111](http://123.207.41.18:2637/images/2024/04/202404251927909.jpg)

解析完成后，根据解析的结果判断日志的格式是否正确，并将需要用到的输出器添加到m_items中

这里用map来存储格式名和输出器的对应关系，便于根据格式名找到对应的输出器存入m_items中

```c++
static std::map<std::string,
                    std::function<FormatItem::ptr(const std::string& str)> >
        s_format_items = {
#define XX(str, C)                                                             \
    {                                                                          \
        #str,                                                                  \
            [](const std::string& fmt) { return FormatItem::ptr(new C(fmt)); } \
    }

            XX(m, MessageFormatItem),     // m:消息
            XX(p, LevelFormatItem),       // p:日志级别
            XX(r, ElapseFormatItem),      // r:累计毫秒数
            XX(c, NameFormatItem),        // c:日志名称
            XX(t, ThreadIdFormatItem),    // t:线程id
            XX(n, NewLineFormatItem),     // n:换行
            XX(d, DateTimeFormatItem),    // d:时间
            XX(f, FilenameFormatItem),    // f:文件名
            XX(l, LineFormatItem),        // l:行号
            XX(T, TabFormatItem),         // T:Tab
            XX(F, FiberIdFormatItem),     // F:协程id
            XX(N, ThreadNameFormatItem),  // N:线程名称
#undef XX
        };
```

### LogAppender-日志目标类

纯虚类

内部包含一个LogFormatter成员和一个log方法，日志事件先经过LogFormatter格式化后再输出到对应的输出地派生出不同的Appender类型，比如StdoutLogAppender和FileLogAppender，分别表示输出到终端和文件

---

纯虚函数log，打印日志到指定地

---

内部成员

```c++
// 日志级别
LogLevel::Level m_level = LogLevel::DEBUG;
// 是否有自己的日志格式器
bool m_hasFormatter = false;
// Mutex
MutexType m_mutex;
// 日志格式器
LogFormatter::ptr m_formatter;
```

## Logger类

日志器类，每次打印日志需要获取一个Logger类

Logger的实现包含了日志级别，日志器名称，主日志器，以及一个LogAppender数组，日志事件由log方法输出，log方法首先判断日志级别是否达到本Logger的级别要求，是则将日志传给各个LogAppender进行输出，否则抛弃这条日志

---

内部成员

```c++
// 日志名称
std::string m_name;
// 日志级别，大于该级别的日志才会被打印
LogLevel::Level m_level;
// Mutex，互斥访下面三个元素
MutexType m_mutex;
// 日志目标集合
std::list<LogAppender::ptr> m_appenders;
// 日志格式器
LogFormatter::ptr m_formatter;
// 主日志器
Logger::ptr m_root;
```

如果日志目标集合中输出器没有事先指定格式，则会以m_formatter作为格式

## LoggerManager-日志器管理类

单例模式，用于统一管理全部的日志器，提供getLogger()方法用于创建/获取日志器。内部维护一个名称到日志器的map，当获取的日志器存在时，直接返回对应的日志器指针，否则创建对应的日志器并返回

## 日志宏

```c++
/**
 * @brief 使用流式方式将日志级别level的日志写入到logger
 * @details 返回一个输入流
 * @todo 启动依赖耗时未实现
 */
#define SYLAR_LOG_LEVEL(logger, level)                                  \
    if (logger->getLevel() <= level)                                    \
    sylar::LogEventWrap(                                                \
        sylar::LogEvent::ptr(new sylar::LogEvent(                       \
            logger, level, __FILE__, __LINE__, 0, sylar::GetThreadId(), \
            sylar::GetFiberId(), time(0), sylar::Thread::GetName())))   \
        .getSS()

/**
 * @brief 使用格式化方式将日志级别level的日志写入到logger
 */
#define SYLAR_LOG_FMT_LEVEL(logger, level, fmt, ...)                    \
    if (logger->getLevel() <= level)                                    \
    sylar::LogEventWrap(                                                \
        sylar::LogEvent::ptr(new sylar::LogEvent(                       \
            logger, level, __FILE__, __LINE__, 0, sylar::GetThreadId(), \
            sylar::GetFiberId(), time(0), sylar::Thread::GetName())))   \
        .getEvent()                                                     \
        ->format(fmt, __VA_ARGS__)
```

## 日志输出流程

1. 初始化LogFormatter，LogAppender, Logger
2. 通过宏定义提供流式风格和格式化风格的日志接口。每次写日志时，通过宏自动生成对应的日志事件LogEvent，并且将日志事件和日志器Logger包装到一起，生成一个LogEventWrap对象
3. 日志接口执行结束后，LogEventWrap对象析构，在析构函数里调用Logger的log方法将日志事件进行输出

## 测试

```c++
int main() {
    sylar::Logger::ptr logger(new sylar::Logger);
    logger->addAppender(sylar::LogAppender::ptr(new sylar::StdoutLogAppender));

    sylar::FileLogAppender::ptr file_appender(
        new sylar::FileLogAppender("./log.txt"));
    sylar::LogFormatter::ptr fmt(new sylar::LogFormatter("%d%T%p%T%m%n"));
    file_appender->setFormatter(fmt);
    file_appender->setLevel(sylar::LogLevel::ERROR);

    logger->addAppender(file_appender);

    // sylar::LogEvent::ptr event(new sylar::LogEvent(__FILE__, __LINE__, 0,
    // sylar::GetThreadId(), sylar::GetFiberId(), time(0))); event->getSS() <<
    // "hello sylar log"; logger->log(sylar::LogLevel::DEBUG, event);
    std::cout << "hello sylar log" << std::endl;

    SYLAR_LOG_INFO_TEST(logger) << "test macro";
    SYLAR_LOG_ERROR_TEST(logger) << "test macro error";

    SYLAR_LOG_FMT_ERROR_TEST(logger, "test macro fmt error %s", "aa");

    auto l = sylar::LoggerMgr::GetInstance()->getLogger("xx");
    SYLAR_LOG_INFO_TEST(l) << "xxx";
    return 0;
}
```

